## 数据结构基本概念

#### (1)线性表

线性表又分为：顺序存储、链式存储

##### 顺序存储-----顺序表

一个线性表是n个具有相同特性的数据元素的有限序列。数据元素是一个抽象的符号，其具体含义在不同的情况下一般不同。

数组的特点是：寻址容易，插入和删除困难；

##### 链式存储----（单链表、双链表、循环链表）->指针实现、静态链表->数组实现

链表里面节点的地址不是连续的，是通过指针连起来的。

链表的特点是：寻址困难，插入和删除容易。

#### (2)哈希表

**哈希表hashtable(key，value) 就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。**

接下来解释的是最常用的一种方法——拉链法，我们可以理解为“链表的数组”，如图：

![](/Users/awakeyoyoyo/Desktop/Java_Development_Note/images/588112-20180626163257503-1905188703.png)

左边很明显是个数组，数组的每个成员包括一个指针，指向一个链表的头，当然这个链表可能为空，也可能元素很多。我们根据元素的一些特征把元素分配到不同的链表中去，也是根据这些特征，找到正确的链表，再从链表中找出这个元素。

Hash 表的查询速度非常的快，几乎是O(1)的时间复杂度。

hash就是找到一种数据内容和数据存放地址之间的映射关系。

hash表的运行过程

1、散列表的查找步骤 （散列法：元素特征转变为数组下标的方法）

当存储记录时，通过散列函数计算出记录的散列地址

当查找记录时，我们通过同样的是散列函数计算记录的散列地址，并按此散列地址访问该记录

2、如果两个字符串在哈希表中对应的位置相同，哈希表的每个入口挂一个链表，保存所有对应的字符串

#### 优缺点

- 优点：不论哈希表中有多少数据，查找、插入、删除（有时包括删除）只需要接近常量的时间即0(1）的时间级。实际上，这只需要几条机器指令。哈希表运算得非常快，在计算机程序中，如果需要在一秒种内查找上千条记录通常使用哈希表（例如拼写检查器)哈希表的速度明显比树快，树的操作通常需要O(N)的时间级。哈希表不仅速度快，编程实现也相对容易。如果不需要有序遍历数据，并且可以提前预测数据量的大小。那么哈希表在速度和易用性方面是无与伦比的。

- 缺点：它是基于数组的，数组创建后难于扩展，某些哈希表被基本填满时，性能下降得非常严重，所以程序员必须要清楚表中将要存储多少数据（或者准备好定期地把数据转移到更大的哈希表中，这是个费时的过程）。

**哈希表的原理：**

　　 1，对对象元素中的关键字(对象中的特有数据)，进行哈希算法的运算，并得出一个具体的算法值，这个值 称为**哈希值**。

　　2，哈希值就是这个元素的位置。

　　3，如果哈希值出现冲突，再次判断这个关键字对应的对象是否相同。如果对象相同，就不存储，因为元素重复。如果对象不同，就存储，在原来对象的哈希值基础 +1顺延。

　　4，存储哈希值的结构，我们称为哈希表。

　　5，既然哈希表是根据哈希值存储的，为了提高效率，最好保证对象的关键字是唯一的。

　　这样可以尽量少的判断关键字对应的对象是否相同，提高了哈希表的操作效率。

**扩展:**

相同的字符串如果存进去，**哈希值相同**并且**equals方法为true**，不会存入相同的

只要哈希值相同或者equals方法为true都成立才不会存入，**只要其中一条不满足，都会储存**

**哈希表存储过程：**

1.调用对象的哈希值(通过一个函数f()得到哈希值):**存储位置** **= f(关键字)**

2.集合在容器内搜索有没有重复的哈希值，如果没有，存入新元素，记录哈希值

3.再次存储，重复上边的过程

4.如果有重复的哈希值，调用后来者的equals方法，参数为前来者，结果得到true，集合判断为重复元素，不存入

**哈希冲突**

如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的**哈希冲突**，也叫哈希碰撞。前面我们提到过，哈希函数的设计至关重要，好的哈希函数会尽可能地保证 **计算简单**和**散列地址分布均匀****,**但是，我们需要清楚的是，数组是一块连续的**固定长度**的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？

**哈希冲突的解决方案有多种：**

开放定址法（发生冲突，继续寻找下一块未被占用的存储地址）

再散列函数法

链地址法，而**HashMap**即是采用了链地址法，也就是**数组****+链表**的方式

**关于hashcode和equals的一些问题，在面试中会问道：**

1.两个对象哈希值相同，那么equals方法一定返回true吗？

**不一定:**取决于如何重写equals，如果重写固定了它返回false，结果就一定是false

2.equals方法返回true，那么哈希值一定相同吗？

equals返回为true,则两者的hashcode一定相等，意即相等的对象必须具有相等的[哈希码](https://www.baidu.com/s?wd=哈希码&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1d9ujb3nvcYuW-Wn1RdrHP90ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EnHTdn1Tvnj0YPHDsPWDvrjD3r0)。每当equals方法被覆写，通常需要重写hashCode方法从而保持对象行为的一致性。

### (3)数组

采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n) 

### (4)区别

**1.数组**

**优点：(1)随机访问效率高(根据下标查询)，(2)搜索效率较高(可使用折半方法)。**

**缺点：(1)内存连续且固定，存储效率低。(2)插入和删除效率低(可能会进行数组拷贝或扩容)。**

**2.链表**

**优点：(1)不要求连续内存，内存利用率高，(2)插入和删除效率高(只需要改变指针指向)。**

**缺点：(1)不支持随机访问，(2)搜索效率低(需要遍历)。**

**3.Hash表**

**优点：(1)搜索效率高，(2)插入和删除效率较高，**

**缺点：(1)内存利用率低(基于数组)，(2)存在散列冲突。**



# 集合类种重要概念词解释

#### **(1).泛型**

java中很重要的概念, 集合里面应用很多.

集合的元素，可以是任意类型对象的引用，如果把某个对象放入集合，则会忽略它的类型，就会把它当做Object类型处理.

泛型则是规定了某个集合只可以存放特定类型的对象的引用，会在编译期间进行类型检查,可以直接指定类型来获取集合元素

在泛型集合中有能够存入泛型类型的对象实例还可以存入泛型的子类型的对象实例

**注意：**

1 泛型集合中的限定类型，不能使用基本数据类型 即存储的要求是对象咯

2 可以通过使用包装类（Integer...）限定允许存放基本数据类型

**泛型的好处**

1 提高了安全性（将运行期的错误转换到编译期）

2 省去强转的麻烦

#### **(2).哈希值**

1 就是一个十进制的整数，有操作系统随机给出

2 可以使用Object类中的方法hashCode获取哈希值

3 Object中源码: **int hashCode()**返回该对象的哈希码值；

源码：

**public native int hashCode();**

**native**:指调用了本地操作系统的方法实

#### **(3).平衡二叉树(称AVL树)**

其特点是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。也就是说该二叉树的任何一个子节点，其左右子树的高度都相近。

注意:

关键点是左子树和右子树的深度的绝对值不超过1

**那什么是左子树深度和右子树深度呢?**

![img](https://images2018.cnblogs.com/blog/588112/201806/588112-20180626163747154-56316670.png)

如上图中:

如果插入6元素, 则8的左子树深度就为2, 右子树深度就为0,绝对值就为2, 就不是一个平很二叉树

#### **[1].二叉排序树**（leetcode写算法题的时候碰过）

1若左子树不空，则左子树上所有结点的值均小于它的根结点的值；

2若右子树不空，则右子树上所有结点的值均大于它的根结点的值；

3左、右子树也分别为二叉排序树

## **(4).红黑树**

红黑树（Red Black Tree） 是一种自平衡二叉查找树

(1) 检索效率O(log *n*)

(2) 红黑树的五点规定：

1.每个结点要么是红的要么是黑的

2.根结点是黑的

3.每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的

4.如果一个结点是红的，那么它的两个儿子都是黑的**（反之不一定）**

5.对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点

它的每个结点都额外有一个颜色的属性，颜色只有两种：红色和黑色。

示例:(这块难度比较大, 建议自行百度,查阅相关文档)